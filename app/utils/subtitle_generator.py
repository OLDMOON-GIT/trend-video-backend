"""
Subtitle generation utilities (ASS format) using Whisper
Extracted from long_form_creator.py, create_video_from_folder.py, and video_merge.py
"""

import whisper
import os
from typing import List, Dict, Optional, Tuple
import logging

logger = logging.getLogger(__name__)


class SubtitleSegment:
    """Represents a subtitle segment with timing and text."""

    def __init__(self, start: float, end: float, text: str):
        self.start = start
        self.end = end
        self.text = text

    def __repr__(self):
        return f"SubtitleSegment(start={self.start:.2f}, end={self.end:.2f}, text='{self.text}')"


def format_ass_time(seconds: float) -> str:
    """
    Convert seconds to ASS timestamp format (H:MM:SS.CS).

    Args:
        seconds: Time in seconds

    Returns:
        str: Formatted timestamp (e.g., "0:01:23.45")
    """
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    centiseconds = int((seconds % 1) * 100)

    return f"{hours}:{minutes:02d}:{secs:02d}.{centiseconds:02d}"


def generate_ass_subtitle(
    segments: List[SubtitleSegment],
    output_path: str,
    style_config: Optional[Dict[str, str]] = None
) -> bool:
    """
    Generate ASS subtitle file from segments.

    Args:
        segments: List of subtitle segments
        output_path: Path to save the ASS file
        style_config: Optional style configuration dictionary

    Returns:
        bool: True if successful, False otherwise
    """
    # Default style configuration
    default_style = {
        "Name": "Default",
        "Fontname": "Arial",
        "Fontsize": "48",
        "PrimaryColour": "&H00FFFFFF",  # White
        "SecondaryColour": "&H000000FF",  # Red
        "OutlineColour": "&H00000000",  # Black
        "BackColour": "&H80000000",  # Semi-transparent black
        "Bold": "1",
        "Italic": "0",
        "Underline": "0",
        "StrikeOut": "0",
        "ScaleX": "100",
        "ScaleY": "100",
        "Spacing": "0",
        "Angle": "0",
        "BorderStyle": "1",
        "Outline": "3",
        "Shadow": "2",
        "Alignment": "2",  # Bottom center
        "MarginL": "10",
        "MarginR": "10",
        "MarginV": "20",
        "Encoding": "1"
    }

    # Merge with custom style if provided
    if style_config:
        default_style.update(style_config)

    try:
        with open(output_path, "w", encoding="utf-8") as f:
            # Write ASS header
            f.write("[Script Info]\n")
            f.write("; Script generated by subtitle_generator\n")
            f.write("ScriptType: v4.00+\n")
            f.write("PlayResX: 1920\n")
            f.write("PlayResY: 1080\n")
            f.write("WrapStyle: 0\n")
            f.write("ScaledBorderAndShadow: yes\n")
            f.write("YCbCr Matrix: TV.709\n")
            f.write("\n")

            # Write styles section
            f.write("[V4+ Styles]\n")
            f.write("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, "
                   "Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, "
                   "Alignment, MarginL, MarginR, MarginV, Encoding\n")

            style_line = (
                f"Style: {default_style['Name']},{default_style['Fontname']},{default_style['Fontsize']},"
                f"{default_style['PrimaryColour']},{default_style['SecondaryColour']},{default_style['OutlineColour']},"
                f"{default_style['BackColour']},{default_style['Bold']},{default_style['Italic']},"
                f"{default_style['Underline']},{default_style['StrikeOut']},{default_style['ScaleX']},"
                f"{default_style['ScaleY']},{default_style['Spacing']},{default_style['Angle']},"
                f"{default_style['BorderStyle']},{default_style['Outline']},{default_style['Shadow']},"
                f"{default_style['Alignment']},{default_style['MarginL']},{default_style['MarginR']},"
                f"{default_style['MarginV']},{default_style['Encoding']}\n"
            )
            f.write(style_line)
            f.write("\n")

            # Write events section
            f.write("[Events]\n")
            f.write("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n")

            for segment in segments:
                start_time = format_ass_time(segment.start)
                end_time = format_ass_time(segment.end)
                text = segment.text.replace("\n", "\\N")  # ASS uses \N for line breaks

                f.write(
                    f"Dialogue: 0,{start_time},{end_time},{default_style['Name']},,0,0,0,,{text}\n"
                )

        logger.info(f"Generated ASS subtitle file: {output_path} ({len(segments)} segments)")
        return True

    except Exception as e:
        logger.error(f"Failed to generate ASS subtitle: {e}")
        return False


def transcribe_audio_to_segments(
    audio_path: str,
    model_name: str = "base",
    language: Optional[str] = None
) -> List[SubtitleSegment]:
    """
    Transcribe audio file to subtitle segments using Whisper.

    Args:
        audio_path: Path to audio file
        model_name: Whisper model to use (tiny, base, small, medium, large)
        language: Language code (e.g., 'ko', 'en', 'ja'). If None, auto-detect.

    Returns:
        List[SubtitleSegment]: List of transcribed segments

    Raises:
        RuntimeError: If transcription fails
    """
    try:
        logger.info(f"Loading Whisper model: {model_name}")
        model = whisper.load_model(model_name)

        logger.info(f"Transcribing audio: {audio_path}")
        result = model.transcribe(
            audio_path,
            language=language,
            task="transcribe",
            word_timestamps=True
        )

        segments = []
        for segment in result["segments"]:
            start = segment["start"]
            end = segment["end"]
            text = segment["text"].strip()

            if text:  # Skip empty segments
                segments.append(SubtitleSegment(start, end, text))

        logger.info(f"Transcription complete: {len(segments)} segments")
        return segments

    except Exception as e:
        logger.error(f"Failed to transcribe audio: {e}")
        raise RuntimeError(f"Transcription failed: {e}")


def generate_subtitle_from_audio(
    audio_path: str,
    output_path: str,
    model_name: str = "base",
    language: Optional[str] = None,
    style_config: Optional[Dict[str, str]] = None
) -> bool:
    """
    Generate ASS subtitle file from audio using Whisper transcription.

    Args:
        audio_path: Path to audio file
        output_path: Path to save the ASS subtitle file
        model_name: Whisper model to use
        language: Language code (if None, auto-detect)
        style_config: Optional style configuration

    Returns:
        bool: True if successful, False otherwise
    """
    try:
        # Transcribe audio
        segments = transcribe_audio_to_segments(audio_path, model_name, language)

        # Generate ASS file
        return generate_ass_subtitle(segments, output_path, style_config)

    except Exception as e:
        logger.error(f"Failed to generate subtitle from audio: {e}")
        return False


def merge_short_segments(
    segments: List[SubtitleSegment],
    min_duration: float = 1.0,
    max_duration: float = 10.0
) -> List[SubtitleSegment]:
    """
    Merge short subtitle segments to improve readability.

    Args:
        segments: List of subtitle segments
        min_duration: Minimum duration for a segment (seconds)
        max_duration: Maximum duration for merged segments (seconds)

    Returns:
        List[SubtitleSegment]: Merged segments
    """
    if not segments:
        return []

    merged = []
    current_segment = None

    for segment in segments:
        duration = segment.end - segment.start

        if current_segment is None:
            current_segment = SubtitleSegment(segment.start, segment.end, segment.text)
        else:
            # Check if we should merge with current segment
            merged_duration = segment.end - current_segment.start
            current_duration = current_segment.end - current_segment.start

            if (duration < min_duration or current_duration < min_duration) and merged_duration <= max_duration:
                # Merge segments
                current_segment.end = segment.end
                current_segment.text += " " + segment.text
            else:
                # Save current segment and start new one
                merged.append(current_segment)
                current_segment = SubtitleSegment(segment.start, segment.end, segment.text)

    # Add the last segment
    if current_segment:
        merged.append(current_segment)

    logger.info(f"Merged segments: {len(segments)} -> {len(merged)}")
    return merged


def split_long_segments(
    segments: List[SubtitleSegment],
    max_duration: float = 10.0,
    max_chars: int = 100
) -> List[SubtitleSegment]:
    """
    Split long subtitle segments for better readability.

    Args:
        segments: List of subtitle segments
        max_duration: Maximum duration for a segment (seconds)
        max_chars: Maximum characters per segment

    Returns:
        List[SubtitleSegment]: Split segments
    """
    split_segments = []

    for segment in segments:
        duration = segment.end - segment.start
        text_length = len(segment.text)

        # Check if segment needs splitting
        if duration <= max_duration and text_length <= max_chars:
            split_segments.append(segment)
            continue

        # Split by duration or text length
        words = segment.text.split()
        num_splits = max(
            int(duration / max_duration) + 1,
            int(text_length / max_chars) + 1
        )

        words_per_split = len(words) // num_splits
        time_per_split = duration / num_splits

        for i in range(num_splits):
            start_idx = i * words_per_split
            end_idx = start_idx + words_per_split if i < num_splits - 1 else len(words)

            split_text = " ".join(words[start_idx:end_idx])
            split_start = segment.start + (i * time_per_split)
            split_end = split_start + time_per_split

            if split_text.strip():
                split_segments.append(SubtitleSegment(split_start, split_end, split_text))

    logger.info(f"Split segments: {len(segments)} -> {len(split_segments)}")
    return split_segments


def adjust_subtitle_timing(
    segments: List[SubtitleSegment],
    offset: float = 0.0,
    speed_factor: float = 1.0
) -> List[SubtitleSegment]:
    """
    Adjust subtitle timing by adding offset and/or changing speed.

    Args:
        segments: List of subtitle segments
        offset: Time offset in seconds (positive = delay, negative = advance)
        speed_factor: Speed multiplication factor (1.0 = normal, 2.0 = double speed)

    Returns:
        List[SubtitleSegment]: Adjusted segments
    """
    adjusted = []

    for segment in segments:
        new_start = (segment.start / speed_factor) + offset
        new_end = (segment.end / speed_factor) + offset

        # Ensure times are non-negative
        new_start = max(0.0, new_start)
        new_end = max(0.0, new_end)

        adjusted.append(SubtitleSegment(new_start, new_end, segment.text))

    return adjusted


def create_korean_subtitle_style() -> Dict[str, str]:
    """
    Create a Korean-optimized subtitle style configuration.

    Returns:
        Dict[str, str]: Style configuration for Korean text
    """
    return {
        "Fontname": "Malgun Gothic",  # Korean font
        "Fontsize": "52",
        "PrimaryColour": "&H00FFFFFF",  # White
        "OutlineColour": "&H00000000",  # Black outline
        "BackColour": "&H80000000",  # Semi-transparent shadow
        "Bold": "1",
        "Outline": "3",
        "Shadow": "2",
        "Alignment": "2",  # Bottom center
        "MarginV": "30",
    }


def create_english_subtitle_style() -> Dict[str, str]:
    """
    Create an English-optimized subtitle style configuration.

    Returns:
        Dict[str, str]: Style configuration for English text
    """
    return {
        "Fontname": "Arial",
        "Fontsize": "48",
        "PrimaryColour": "&H00FFFFFF",  # White
        "OutlineColour": "&H00000000",  # Black outline
        "BackColour": "&H80000000",  # Semi-transparent shadow
        "Bold": "1",
        "Outline": "2",
        "Shadow": "1",
        "Alignment": "2",  # Bottom center
        "MarginV": "20",
    }


def validate_subtitle_file(subtitle_path: str) -> Tuple[bool, Optional[str]]:
    """
    Validate an ASS subtitle file.

    Args:
        subtitle_path: Path to the subtitle file

    Returns:
        Tuple[bool, Optional[str]]: (is_valid, error_message)
    """
    if not os.path.exists(subtitle_path):
        return False, f"Subtitle file not found: {subtitle_path}"

    try:
        with open(subtitle_path, "r", encoding="utf-8") as f:
            content = f.read()

        # Check for required sections
        required_sections = ["[Script Info]", "[V4+ Styles]", "[Events]"]
        for section in required_sections:
            if section not in content:
                return False, f"Missing required section: {section}"

        # Check if there are any dialogue lines
        if "Dialogue:" not in content:
            return False, "No dialogue lines found"

        return True, None

    except Exception as e:
        return False, f"Failed to validate subtitle file: {e}"
